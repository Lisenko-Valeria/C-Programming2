# 1.Создание потока
Написана программа, которая создает поток с помощью pthread_create(). Использованны атрибуты по умолчанию. Родительский и дочерний потоки выводят на экран по 5 строк текста.
<img src="img/screen1.jpg"> 
<img src="img/screen2.jpg"> 
# 2.Ожидание потока 
Модифицировано упр.1 так, что родительский поток выводит текст после завершения дочернего потока. 
<img src="img/screen3.jpg"> 
<img src="img/screen4.jpg"> 
# 3.Параметры потока
Модифицировано упр.2 так, что основной поток создает 4 потока, исполняющих одну и ту же функцию. Эта функция распечатывает последовательность текстовых строк, переданных как параметр. Каждый из созданных потоков распечатывает различные последовательности строк.
<img src="img/screen5.jpg"> 
<img src="img/screen6.jpg"> 
<img src="img/screen7.jpg"> 
# 4.Завершение нити без ожидания
Добавлен сон с помощью sleep() в функцию потоков между выводами строк. Спустя две секунды после создания дочерних потоков основной поток прервает работу всех дочерних потоков с помощью pthread_cancel().
<img src="img/screen8.jpg"> 
<img src="img/screen9.jpg"> 
<img src="img/screen10.jpg"> 
# 5.Обработать завершение потока
Модифицировано упр. 4 так, что дочерний поток перед завершением распечатывает сообщение об этом. Использован pthread_cleanup_push()
<img src="img/screen11.jpg"> 
<img src="img/screen12.jpg"> 
# 6.Реализовать простой Sleepsort
Реализован алгоритм сортировки Sleepsort с асимптотикой O(N) (по времени). Суть алгоритма: на вход подается массив, пусть будет не более 50 элементов и пусть будет состоять из целочисленных значений. Для каждого элемента массива создается отдельный поток, в который в качестве аргумента передается значение элемента. Сам поток должен уйти в сон с помощью sleep() или usleep() с параметром равным аргументу потока (значение элемента массива), а после вывести на экран значение.
<img src="img/screen13.jpg"> 
<img src="img/screen14.jpg"> 
<img src="img/screen15.jpg"> 